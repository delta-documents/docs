searchNodes=[{"doc":"Delta Elixir API","ref":"Delta.html","title":"Delta","type":"module"},{"doc":"","ref":"Delta.html#t:uuid4/0","title":"Delta.uuid4/0","type":"type"},{"doc":"JWT access/refresh authentication","ref":"Delta.Authentication.html","title":"Delta.Authentication","type":"module"},{"doc":"Granular authorization policies","ref":"Delta.Authorization.html","title":"Delta.Authorization","type":"module"},{"doc":"Internal commits API An interface to work on top of Delta.DataLayer which should also implement Delta.Commit","ref":"Delta.Commit.html","title":"Delta.Commit","type":"behaviour"},{"doc":"Adds commits to a document's history and checks for history consistency. Checks for conflicts of the first commit. If the commit has resolvable conflict (commits's delta does not overlaps with deltas of all conflicting commits), resolves the conflict and writes the commit. If the commit has no conflicts, writes the commit. If the commit has unresolvable conflict, aborts with Delta.Errors.Conflict.t() .","ref":"Delta.Commit.html#add_commits/1","title":"Delta.Commit.add_commits/1","type":"function"},{"doc":"Deletes commit with id = commit_id . Returns {:atomic, :ok} even if commit with id = commit_id does not exist.","ref":"Delta.Commit.html#delete/1","title":"Delta.Commit.delete/1","type":"function"},{"doc":"Same as Delta.Commit.delete/1 , but returns data with continuation","ref":"Delta.Commit.html#c:delete/3","title":"Delta.Commit.delete/3","type":"callback"},{"doc":"","ref":"Delta.Commit.html#get/2","title":"Delta.Commit.get/2","type":"function"},{"doc":"Same as Delta.Commit.get/1 , but returns data with continuation","ref":"Delta.Commit.html#c:get/3","title":"Delta.Commit.get/3","type":"callback"},{"doc":"Gets id from id()","ref":"Delta.Commit.html#id/1","title":"Delta.Commit.id/1","type":"function"},{"doc":"Lists commits of Delta.Document with id = document_id . Expensive operation. If document does not exists, returns empty list","ref":"Delta.Commit.html#list/1","title":"Delta.Commit.list/1","type":"function"},{"doc":"Same as Delta.Commit.list/1 , but returns data with continuation","ref":"Delta.Commit.html#c:list/2","title":"Delta.Commit.list/2","type":"callback"},{"doc":"Lists commit from newest – from_commit_id to oldest – to_commit_id . If commit with id = from_commit_id does not exist, assumes it to be the latest commit. If commit with id = to_commit_id does not exist, assumes it to be the first commit.","ref":"Delta.Commit.html#list/3","title":"Delta.Commit.list/3","type":"function"},{"doc":"Same as Delta.Commit.list/2 , but returns data with continuation","ref":"Delta.Commit.html#c:list/4","title":"Delta.Commit.list/4","type":"callback"},{"doc":"Checks if two commits overlap Commits are overlapping if their patches overlap","ref":"Delta.Commit.html#overlap?/2","title":"Delta.Commit.overlap?/2","type":"function"},{"doc":"Checks if commits have conflict(s) with history and resolves them if possible. Commits must be sorted by theirs (would be) ascending order – first commit is the first element of the list. History must be sorted by descnding order – last commit is the first element of the list.","ref":"Delta.Commit.html#resolve_conflicts/2","title":"Delta.Commit.resolve_conflicts/2","type":"function"},{"doc":"Squashes Delta.Commit with id = commit_id_2 into one with id = commit_id_1 . Resulting commit will have metadata of the second commit. The second commit may not exist. Aborts with %Delta.Errors.DoesNotExist{} if commit with id = commit_id_1 or id = commit_id_2 does not exist.","ref":"Delta.Commit.html#squash/2","title":"Delta.Commit.squash/2","type":"function"},{"doc":"Same as Delta.Commit.squash/2 , but returns data with continuation","ref":"Delta.Commit.html#c:squash/4","title":"Delta.Commit.squash/4","type":"callback"},{"doc":"Validates commit according to the following rules: :id – must be UUIDv4 in default form :previous_commit_id – must be UUIDv4 in default form of previous commit or nil :patch – must be valid RFC 6092 Json delta :document_id – must be valid UUIDv4 of document in default form. Note: other functions exptect valid input, therefor before passing data to them it should be validated.","ref":"Delta.Commit.html#validate/1","title":"Delta.Commit.validate/1","type":"function"},{"doc":"Validates commits according to the following rules: Commits must be sequential, i. e. commit[i].id = commit[i + 1].previous_id All commits must have same :document_id Each commit must be valid (See validate/1 )","ref":"Delta.Commit.html#validate_many/1","title":"Delta.Commit.validate_many/1","type":"function"},{"doc":"Writes commit.","ref":"Delta.Commit.html#write/1","title":"Delta.Commit.write/1","type":"function"},{"doc":"Same as Delta.Commit.write/1, but returns data with continuation","ref":"Delta.Commit.html#c:write/3","title":"Delta.Commit.write/3","type":"callback"},{"doc":"Writes commits.","ref":"Delta.Commit.html#write_many/1","title":"Delta.Commit.write_many/1","type":"function"},{"doc":"Same as Delta.Commit.write_many/1, but returns data with continuation","ref":"Delta.Commit.html#c:write_many/3","title":"Delta.Commit.write_many/3","type":"callback"},{"doc":"","ref":"Delta.Commit.html#t:id/0","title":"Delta.Commit.id/0","type":"type"},{"doc":"Represents a commit made by user to a document. Fields :id – UUIDv4 in default form. Required :previous_commit_id – UUIDv4 in default form. Used to order commits of particular document to form a history. Required :document_id – UUIDv4 in default from. Required :order – Order of commit in document's history. Autogenerated :autosquash? – Should the commits be squashed with the last commit with :patch with same paths :patch – Changes to document in RFC 6902 json patch format. Required :reverse_patch – RFC 6902 json patch to revert document to previous state. Autogenerated :meta – any metadata, e. g. user who made it :updated_at – when the commit was updated. Autosquashing Autosquashing is delta's feature for continious and frequent document updates. It reduces the number of commits by squashing (see Delta.Commit.squash/2 ). If there will be a commit with autosquahs?: false and its delta will have any path which is being autosquahed at the moment, the commit will not be squashed. In order for two commits to be autosquashed, they must be marked autosquash?: true and have delta with same paths. For autosquash commit no checks of previous_commit_id are performed.","ref":"Delta.Commit.html#t:t/0","title":"Delta.Commit.t/0","type":"type"},{"doc":"Caching layer for Delta.Commit Works on top of mnesia. When started, creates mnesia table :&quot;\#{Delta.Commit.CacheLayer}.\#{document_id}&quot; on the node it was started on. All operations are performed on this table. All operations are accumulated and then periodically replicated on persistent data layer.","ref":"Delta.Commit.CacheLayer.html","title":"Delta.Commit.CacheLayer","type":"module"},{"doc":"","ref":"Delta.Commit.CacheLayer.html#add_commits/3","title":"Delta.Commit.CacheLayer.add_commits/3","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"Delta.Commit.CacheLayer.html#child_spec/1","title":"Delta.Commit.CacheLayer.child_spec/1","type":"function"},{"doc":"Returns anonyumous function /0, which deletes mnesia table used by the layer.","ref":"Delta.Commit.CacheLayer.html#crash_handler/1","title":"Delta.Commit.CacheLayer.crash_handler/1","type":"function"},{"doc":"Deletes commit. Always successful. Continuation deletes commit on antother data layer. See Delta.Commit.delete/1","ref":"Delta.Commit.CacheLayer.html#delete/3","title":"Delta.Commit.CacheLayer.delete/3","type":"function"},{"doc":"Gets commit. If it exists, continuation is alwayus nil See Delta.Commit.get/1","ref":"Delta.Commit.CacheLayer.html#get/3","title":"Delta.Commit.CacheLayer.get/3","type":"function"},{"doc":"Lists all commits on this data layer. Continuation lists data on another data layer with priority to this data layer. See Delta.Commit.list/1","ref":"Delta.Commit.CacheLayer.html#list/2","title":"Delta.Commit.CacheLayer.list/2","type":"function"},{"doc":"Lists commits from one to another. Continuation lists data on another data layer with priority to this data layer. See Delta.Commit.list/3","ref":"Delta.Commit.CacheLayer.html#list/4","title":"Delta.Commit.CacheLayer.list/4","type":"function"},{"doc":"Starts this DataLayer with specific document id. Has no options.","ref":"Delta.Commit.CacheLayer.html#start_link/2","title":"Delta.Commit.CacheLayer.start_link/2","type":"function"},{"doc":"Writes commit. Continuation wirtes commit on another data layer. See Delta.Commit.write/1","ref":"Delta.Commit.CacheLayer.html#write/3","title":"Delta.Commit.CacheLayer.write/3","type":"function"},{"doc":"Writes a list of commits. Commits are assumed to have equal document_id . Continuation writes commits on another data layer See Delta.Commit.write_many/1","ref":"Delta.Commit.CacheLayer.html#write_many/3","title":"Delta.Commit.CacheLayer.write_many/3","type":"function"},{"doc":"Persistent layer for Delta.Commit Works on top of MongoDB.","ref":"Delta.Commit.PersistentLayer.html","title":"Delta.Commit.PersistentLayer","type":"module"},{"doc":"Behaviour for connections to Delta. Instances is expected to: manage connection from user join Swarm group Delta.Connection to be able to recieve notifications to handle notificatons asyncronously","ref":"Delta.Connection.html","title":"Delta.Connection","type":"behaviour"},{"doc":"","ref":"Delta.Connection.html#c:handle_call/3","title":"Delta.Connection.handle_call/3","type":"callback"},{"doc":"Sends event to every connection","ref":"Delta.Connection.html#notify/1","title":"Delta.Connection.notify/1","type":"function"},{"doc":"Events for clients: {:created, document_id} – Delta.Document.t() with id = document_id is created {:created, document_id} – Delta.Document.t() with id = document_id is deleted {:added, commit} – Delta.Commit.t() was added {:squashed, into, what} – Delta.Commit.t() what was squashed into","ref":"Delta.Connection.html#t:event/0","title":"Delta.Connection.event/0","type":"type"},{"doc":"Supervises all connection processes","ref":"Delta.Connection.Supervisor.html","title":"Delta.Connection.Supervisor","type":"module"},{"doc":"Behaviour of Delta Data Layers. Data layer is a GenServer, managing operations with entites associated with document. Each instance is expected to: control its uniuqe portion of data. join Swarm group Delta.DataLayer for proper layer_id form resolution.","ref":"Delta.DataLayer.html","title":"Delta.DataLayer","type":"behaviour"},{"doc":"Runs continuation on specified layer","ref":"Delta.DataLayer.html#continue/2","title":"Delta.DataLayer.continue/2","type":"function"},{"doc":"Returns function that should be called on process which monitors data layer .","ref":"Delta.DataLayer.html#c:crash_handler/1","title":"Delta.DataLayer.crash_handler/1","type":"callback"},{"doc":"Converts layer_id to normal form.","ref":"Delta.DataLayer.html#layer_id_normal/1","title":"Delta.DataLayer.layer_id_normal/1","type":"function"},{"doc":"Converts layer_id to pid form.","ref":"Delta.DataLayer.html#layer_id_pid/1","title":"Delta.DataLayer.layer_id_pid/1","type":"function"},{"doc":"Starts data layer for isolating any data related to document.","ref":"Delta.DataLayer.html#c:start_link/2","title":"Delta.DataLayer.start_link/2","type":"callback"},{"doc":"Specifies operation continuation on another data layer. Is executed on data layer with layer_id .","ref":"Delta.DataLayer.html#t:continuation/0","title":"Delta.DataLayer.continuation/0","type":"type"},{"doc":"Identifier for layer instance, can be one of: {module(), Delta.uuid4()} , where module() is data layer module (normal form) pid() of data layer process {module(), Delta.Document.t()} – same as normal form, but id will be extracted from a document. Note that any Delta.uuid4() is valid id in type context, in other words, there is no checks if document exists to be performed.","ref":"Delta.DataLayer.html#t:layer_id/0","title":"Delta.DataLayer.layer_id/0","type":"type"},{"doc":"","ref":"Delta.DataLayer.CacheSupervisor.html","title":"Delta.DataLayer.CacheSupervisor","type":"module"},{"doc":"Runs anonymous function on data layer exit","ref":"Delta.DataLayer.CrashHandler.html","title":"Delta.DataLayer.CrashHandler","type":"module"},{"doc":"Adds data layer crash handler.","ref":"Delta.DataLayer.CrashHandler.html#add/2","title":"Delta.DataLayer.CrashHandler.add/2","type":"function"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"Delta.DataLayer.CrashHandler.html#child_spec/1","title":"Delta.DataLayer.CrashHandler.child_spec/1","type":"function"},{"doc":"Callback implementation for GenServer.init/1 .","ref":"Delta.DataLayer.CrashHandler.html#init/1","title":"Delta.DataLayer.CrashHandler.init/1","type":"function"},{"doc":"Removes crash handler of data layer.","ref":"Delta.DataLayer.CrashHandler.html#remove/1","title":"Delta.DataLayer.CrashHandler.remove/1","type":"function"},{"doc":"Starts crash handler process with name Delta.DataLayer.CrashHandler . API assumes that process is named.","ref":"Delta.DataLayer.CrashHandler.html#start_link/0","title":"Delta.DataLayer.CrashHandler.start_link/0","type":"function"},{"doc":"","ref":"Delta.DataLayer.PersistentSupervisor.html","title":"Delta.DataLayer.PersistentSupervisor","type":"module"},{"doc":"Helpers for working with DateTime","ref":"Delta.Datetime.html","title":"Delta.Datetime","type":"module"},{"doc":"","ref":"Delta.Datetime.html#now!/1","title":"Delta.Datetime.now!/1","type":"function"},{"doc":"Returns DateTime in configured timezone. By default it is &quot;Etc/UTC&quot;","ref":"Delta.Datetime.html#now/1","title":"Delta.Datetime.now/1","type":"function"},{"doc":"Internal documents API","ref":"Delta.Document.html","title":"Delta.Document","type":"module"},{"doc":"Adds list of changes changes to document with id = document_id in transactional manner. Aborts with %Delta.Errors.Conflict{} if changes do not form linear history or one or more changes conflict with existing changes. Aborts with %Delta.Errors.DoesNotExist{} if document with id = document_id does not exist.","ref":"Delta.Document.html#add_changes/2","title":"Delta.Document.add_changes/2","type":"function"},{"doc":"Creates document. Aborts with %Delta.Errors.AlreadyExists{} if document with id = document.id already exist.","ref":"Delta.Document.html#create/1","title":"Delta.Document.create/1","type":"function"},{"doc":"Deletes document and its changes with id = document_id . Reutrns {:atomic, :ok} even if document with id = document_id does not exist.","ref":"Delta.Document.html#delete/1","title":"Delta.Document.delete/1","type":"function"},{"doc":"","ref":"Delta.Document.html#get/1","title":"Delta.Document.get/1","type":"function"},{"doc":"Returns ids of all documents for efficiency reasons","ref":"Delta.Document.html#list/0","title":"Delta.Document.list/0","type":"function"},{"doc":"Returns ids of all documents in collection for efficiency reasons","ref":"Delta.Document.html#list/1","title":"Delta.Document.list/1","type":"function"},{"doc":"Updates document. Aborts with %Delta.Errors.DoesNotExist{} if document with id = document.id does not exist.","ref":"Delta.Document.html#update/2","title":"Delta.Document.update/2","type":"function"},{"doc":"Validates document.id to be UUIDv4 in default form","ref":"Delta.Document.html#validate/1","title":"Delta.Document.validate/1","type":"function"},{"doc":"","ref":"Delta.Document.html#t:collection/0","title":"Delta.Document.collection/0","type":"type"},{"doc":"","ref":"Delta.Document.html#t:id/0","title":"Delta.Document.id/0","type":"type"},{"doc":"","ref":"Delta.Document.html#t:t/0","title":"Delta.Document.t/0","type":"type"},{"doc":"","ref":"Delta.Document.PersistentLayer.html","title":"Delta.Document.PersistentLayer","type":"module"},{"doc":"Helpers for working with errors","ref":"Delta.Errors.html","title":"Delta.Errors","type":"module"},{"doc":"","ref":"Delta.Errors.html#t:t/0","title":"Delta.Errors.t/0","type":"type"},{"doc":"","ref":"Delta.Errors.AlreadyExist.html","title":"Delta.Errors.AlreadyExist","type":"module"},{"doc":"","ref":"Delta.Errors.AlreadyExist.html#t:t/0","title":"Delta.Errors.AlreadyExist.t/0","type":"type"},{"doc":"","ref":"Delta.Errors.Conflict.html","title":"Delta.Errors.Conflict","type":"module"},{"doc":"","ref":"Delta.Errors.Conflict.html#t:t/0","title":"Delta.Errors.Conflict.t/0","type":"type"},{"doc":"","ref":"Delta.Errors.DoesNotExist.html","title":"Delta.Errors.DoesNotExist","type":"module"},{"doc":"","ref":"Delta.Errors.DoesNotExist.html#t:t/0","title":"Delta.Errors.DoesNotExist.t/0","type":"type"},{"doc":"","ref":"Delta.Errors.Validation.html","title":"Delta.Errors.Validation","type":"module"},{"doc":"","ref":"Delta.Errors.Validation.html#t:t/0","title":"Delta.Errors.Validation.t/0","type":"type"},{"doc":"Helper functions for Json Patch (RFC 6902) Note that strictly speaking it is not RFC 6902-compliant. appliance of Delta.Json.Patch to data can never fail test operation is ignored replace and add considered to be the same operations This is due to optimisation reasons.","ref":"Delta.Json.Patch.html","title":"Delta.Json.Patch","type":"module"},{"doc":"If a paths of two operations are the same, keeps the last one","ref":"Delta.Json.Patch.html#normalize/1","title":"Delta.Json.Patch.normalize/1","type":"function"},{"doc":"Returns true if two patches have operations on overlapping paths","ref":"Delta.Json.Patch.html#overlap?/2","title":"Delta.Json.Patch.overlap?/2","type":"function"},{"doc":"Parses json patch into Delta.Json.Patch.t() Note: test operation is ignored replace and add considered to be the same operations","ref":"Delta.Json.Patch.html#parse/1","title":"Delta.Json.Patch.parse/1","type":"function"},{"doc":"Joins two patches together","ref":"Delta.Json.Patch.html#squash/2","title":"Delta.Json.Patch.squash/2","type":"function"},{"doc":"Adds a value and creates all that is required to make the pointer valid.","ref":"Delta.Json.Patch.html#t:add/0","title":"Delta.Json.Patch.add/0","type":"type"},{"doc":"Copies the value from a path to another path. If the from path cant be resolved, the copied value will be nil .","ref":"Delta.Json.Patch.html#t:copy/0","title":"Delta.Json.Patch.copy/0","type":"type"},{"doc":"Moves the value from a path to another path. If the from path cant be resolved, the moved value will be nil .","ref":"Delta.Json.Patch.html#t:move/0","title":"Delta.Json.Patch.move/0","type":"type"},{"doc":"","ref":"Delta.Json.Patch.html#t:operation/0","title":"Delta.Json.Patch.operation/0","type":"type"},{"doc":"Removes value from path. NOOP if the value does not exists.","ref":"Delta.Json.Patch.html#t:remove/0","title":"Delta.Json.Patch.remove/0","type":"type"},{"doc":"List of operations that will be applied in order they are defined.","ref":"Delta.Json.Patch.html#t:t/0","title":"Delta.Json.Patch.t/0","type":"type"},{"doc":"Parser for Json Pointer (RFC 6901)","ref":"Delta.Json.Pointer.html","title":"Delta.Json.Pointer","type":"module"},{"doc":"","ref":"Delta.Json.Pointer.html#overlap?/2","title":"Delta.Json.Pointer.overlap?/2","type":"function"},{"doc":"","ref":"Delta.Json.Pointer.html#parse/1","title":"Delta.Json.Pointer.parse/1","type":"function"},{"doc":"","ref":"Delta.Json.Pointer.html#t:t/0","title":"Delta.Json.Pointer.t/0","type":"type"},{"doc":"","ref":"Delta.Validators.html","title":"Delta.Validators","type":"module"},{"doc":"","ref":"Delta.Validators.html#json_patch/2","title":"Delta.Validators.json_patch/2","type":"function"},{"doc":"","ref":"Delta.Validators.html#json_patch_op/2","title":"Delta.Validators.json_patch_op/2","type":"function"},{"doc":"","ref":"Delta.Validators.html#json_pointer/2","title":"Delta.Validators.json_pointer/2","type":"function"},{"doc":"","ref":"Delta.Validators.html#maybe_uuid4/2","title":"Delta.Validators.maybe_uuid4/2","type":"function"},{"doc":"","ref":"Delta.Validators.html#uuid4/2","title":"Delta.Validators.uuid4/2","type":"function"},{"doc":"","ref":"readme.html","title":"Delta","type":"extras"},{"doc":"Delta is a fast distributed schema-less document-oriented JSON history service written in Elixir, where all updates to documents are represented as a RFC 6092 -like deltas called changes","ref":"readme.html#installation","title":"Delta - Installation","type":"extras"},{"doc":"The purpose of the database is to provide developers with tool to build document-oriented application with soft-realtime distributed history features","ref":"readme.html#purpose","title":"Delta - Purpose","type":"extras"},{"doc":"Documents and collections As it was stated before, Delta is a document-oriented DB, which means that data is stored in a single document without relationships as opposed to a number of SQL tables and relationships. In Delta, documents to not have schema, which means there is no restriction on how your data should be structured. Each document belongs to a collection which are meant to be a way to organize your documents and to serve as a pseudo-datatype. Changes Reading the document Document can be read as a whole using get(collection_id, document_id) of your driver or as a part by passing path in get(collection_id, document_id, path) History Each document has zero or more changes associated with it thus forming history of changes. History is a list of changes linked via previous attribute of a change. Changes may be added but never modified or deleted. Subscriptions Each client can subscribe to changes of a particular document Synchronization To be implemented","ref":"readme.html#principles-and-capabilities","title":"Delta - Principles and capabilities","type":"extras"},{"doc":"Subject to change","ref":"readme.html#api","title":"Delta - API","type":"extras"},{"doc":"To be implemented","ref":"readme.html#drivers","title":"Delta - Drivers","type":"extras"},{"doc":"To be implemented","ref":"readme.html#scaling","title":"Delta - Scaling","type":"extras"},{"doc":"Instal Elixir git clone https//githuhb.com/florius0/delta &amp;&amp; cd delta mix run --no-halt","ref":"readme.html#running","title":"Delta - Running","type":"extras"},{"doc":"def deps do [ { :delta , github : &quot;florius0/delta&quot; } ] end","ref":"readme.html#installation-as-mix-dependency","title":"Delta - Installation as mix dependency","type":"extras"}]